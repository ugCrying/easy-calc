(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["'EcnModule'"] = {}));
})(this, (function (exports) { 'use strict';

  //  获得补位的0和小数点
  function padZero(num) {
    let str = '';
    for (let i = 1; i < Math.abs(num); i++) {
      str += '0';
    }
    if (num < 0) return '0.' + str
    else return str + '0'
  }

  /**
   * 去掉多余的0
   * @param {string} num
   */
  function removeExcessZero(num) {
    if (typeof num !== 'string') num = numToStr(num);

    if (num[0] === '0' && ![undefined, '.'].includes(num[1])) {
      // 前面的0
      let count = 0;
      for (let i = 0; i < num.length; i++) {
        if (num[i] === '0' && ![undefined, '.'].includes(num[i + 1])) count++;

        if (num[i] !== '0') break // 直到读取不是0的字符，停止循环
      }
      if (count > 0) num = num.substring(count);
    }

    if (num.includes('.')) {
      // 小数后面的0
      let partOfinteger = num.substring(0, num.indexOf('.') + 1);
      let partOfDecimal = num.substring(num.indexOf('.') + 1);
      for (let i = partOfDecimal.length - 1; i >= 0; i--) {
        if (partOfDecimal[partOfDecimal.length - 1] === '0') {
          partOfDecimal = partOfDecimal.substring(0, i);
        }
      }
      num = partOfinteger + partOfDecimal;
      if (num.slice(-1) === '.') num = num.substring(0, num.length - 1); // 没有小数位则去掉小数点
    }
    if (['', '-0'].includes(num)) num = '0';
    return num
  }

  /**
   * 转换成完整数字-字符串类型
   * @param {String} val 要格式化的值
   * @param {Number} decimals 小数长度
   * @return {String}
   */
  function numToStr(val, decimals) {
    val = String(val);

    let result = '';

    if (val === 'NaN') {
      result = '0';
    } else if (!val.includes('e')) {
      result = val;
    } else {
      // 包含 e
      let zoomFactor = parseInt(val.substring(val.indexOf('e') + 1)); // 缩放倍数，负数则将小数点前移进行缩小
      //整数部分
      let partOfInt = val.substring(
        parseFloat(val) >= 0 ? 0 : 1,
        val.includes('.') ? val.indexOf('.') : val.indexOf('e')
      );
      // 小数部分
      let partOfDecimal = val.includes('.')
        ? val.substring(val.indexOf('.') + 1, val.indexOf('e'))
        : '';

      if (zoomFactor < 0) {
        // 小数位向左移
        result = padZero(zoomFactor) + partOfInt + partOfDecimal; // 正数
      } else {
        // 小数位向右移
        let arr = (partOfInt + partOfDecimal + padZero(zoomFactor)).split('');
        arr.splice(zoomFactor + 1, 0, '.');
        result = arr.join('');
      }

      if (parseFloat(val) < 0) result = '-' + result; // 负数

    }
    // 小数位控制
    if (result.includes('.')) {
      let partOfinteger = result.substring(0, result.indexOf('.') + 1);
      let partOfDecimal = result.substring(result.indexOf('.') + 1);
      if (decimals !== undefined && partOfDecimal.length > decimals) {
        partOfDecimal = partOfDecimal.substring(0, decimals); // 截取前decimalLength位
      }
      result = partOfinteger + partOfDecimal;
    }

    result = removeExcessZero(result); // 优化:去掉头部多余的0
    return result
  }

  /**
   *
   * @param {string} num
   * @param {string} decimals
   */
  function scaleNum(num, decimals) {
    if (typeof num !== 'string' || num.includes('e')) num = numToStr(num);
    const isNegative = num.includes('-') || parseFloat(num) < 0;
    if (isNegative) num = num.replace('-', '');
    if (decimals > 0) {
      // 放大
      num = num + padZero(decimals);
      const pointI = num.indexOf('.');
      if (pointI >= 0) {
        // 有小数位
        const pre = num.substring(0, pointI);
        const suf = num.substring(pointI + 1);
        const suf_pre = suf.substring(0, decimals);
        const suf_suf = suf.substring(decimals);
        num = pre + (suf_pre + '.' + suf_suf);
      }
    } else if (decimals < 0) {
      // 缩小
      num = padZero(-decimals) + num;
      let pointI = num.indexOf('.');
      if (pointI === -1) pointI = num.length;
      const pre = num.substring(0, pointI);
      const suf = num.substring(pointI + 1);
      const pre_pre = pre.substring(0, pre.length - -decimals);
      const pre_suf = pre.substring(pre.length - -decimals);

      num = pre_pre + '.' + pre_suf + suf;
    }
    num = removeExcessZero(num);
    if (isNegative) num = '-' + num;
    return num
  }

  class Ecn {
    /**
     * Easily Calculate Number Class
     * @param {String || Number || BigInt } originVal 原始值
     * @param {String || Number || BigInt} decimals 精度
     */
    constructor(value, decimals = 0) {
      decimals = Number(decimals);
      let str = numToStr(value);
      // 若是小数则转换为整数
      if (str.includes('.')) {
        const d = str.length - 1 - str.indexOf('.');
        decimals += d;
        str = numToStr(Number(str.replace('.', '')));
      }
      if (str === 'NaN') str = '0';
      const bi = BigInt(str);
      this.origin = {
        decimals,
        num: Number(str),
        str,
        bi,
      };

      // 真实值解析
      // this.number = num / Math.pow(10, decimals) // 此处会产生精度问题
      this.string = scaleNum(str, -decimals); // 可修复精度问题
      this.number = Number(this.string);
    }

    // 生成容器
    static of(value, decimals) {
      return new Ecn(value, decimals)
    }
    // 映射
    map(callback) {
      return new Ecn(callback(this.string))
    }
    // 输出字符串
    toString() {
      return this.string
    }
    // 千分位展示
    toLocaleString() {
      return this.number.toLocaleString()
    }
    // 转为字符串类型的整数
    toIntStr() {
      return numToStr(parseInt(this.number))
    }
    // 保留小数位
    keepDecimals(decimals = 2) {
      return numToStr(this.string, decimals)
    }

    /**
     */
    mul(val) {
      if (!(val instanceof Ecn)) val = new Ecn(val);
      return new Ecn(
        this.origin.bi * val.origin.bi,
        this.origin.decimals + val.origin.decimals
      )
    }
    /**
     */
    div(val) {
      if (!(val instanceof Ecn)) val = new Ecn(val);
      return new Ecn(
        this.origin.bi / val.origin.bi,
        this.origin.decimals - val.origin.decimals
      )
    }
    /**
     */
    plus(val) {
      if (!(val instanceof Ecn)) val = new Ecn(val);
      const [d1, d2] = [this.origin.decimals, val.origin.decimals];
      if (d1 !== d2) {
        if (d1 > d2) {
          return new Ecn(
            this.origin.bi +
              val.origin.bi * BigInt(numToStr(Math.pow(10, d1 - d2))),
            d1
          )
        } else {
          return new Ecn(
            this.origin.bi * BigInt(numToStr(Math.pow(10, d2 - d1))) +
              val.origin.bi,
            d2
          )
        }
      } else {
        return new Ecn(this.origin.bi + val.origin.bi, d1)
      }
    }
    /**
     */
    minus(val) {
      if (!(val instanceof Ecn)) val = new Ecn(val);
      const [d1, d2] = [this.origin.decimals, val.origin.decimals];
      if (d1 !== d2) {
        if (d1 > d2) {
          return new Ecn(
            this.origin.bi -
              val.origin.bi * BigInt(numToStr(Math.pow(10, d1 - d2))),
            d1
          )
        } else {
          return new Ecn(
            this.origin.bi * BigInt(numToStr(Math.pow(10, d2 - d1))) -
              val.origin.bi,
            d2
          )
        }
      } else {
        return new Ecn(this.origin.bi - val.origin.bi, d1)
      }
    }
  }

  exports.Ecn = Ecn;
  exports.numToStr = numToStr;
  exports.scaleNum = scaleNum;

}));
